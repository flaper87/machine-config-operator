// Code generated by go-bindata. DO NOT EDIT.
// sources:
// manifests/bootstrap-pod.yaml
// manifests/controllerconfig.crd.yaml
// manifests/machineconfig.crd.yaml
// manifests/machineconfigcontroller/clusterrole.yaml
// manifests/machineconfigcontroller/clusterrolebinding.yaml
// manifests/machineconfigcontroller/controllerconfig.yaml
// manifests/machineconfigcontroller/deployment.yaml
// manifests/machineconfigcontroller/sa.yaml
// manifests/machineconfigdaemon/OWNERS
// manifests/machineconfigdaemon/clusterrole.yaml
// manifests/machineconfigdaemon/clusterrolebinding.yaml
// manifests/machineconfigdaemon/daemonset.yaml
// manifests/machineconfigdaemon/sa.yaml
// manifests/machineconfigpool.crd.yaml
// manifests/machineconfigserver/clusterrole.yaml
// manifests/machineconfigserver/clusterrolebinding.yaml
// manifests/machineconfigserver/csr-approver-role-binding.yaml
// manifests/machineconfigserver/csr-bootstrap-role-binding.yaml
// manifests/machineconfigserver/csr-renewal-role-binding.yaml
// manifests/machineconfigserver/daemonset.yaml
// manifests/machineconfigserver/node-bootstrapper-sa.yaml
// manifests/machineconfigserver/node-bootstrapper-token.yaml
// manifests/machineconfigserver/sa.yaml
// manifests/master.machineconfigpool.yaml
// manifests/worker.machineconfigpool.yaml

package assets


import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)


type asset struct {
	bytes []byte
	info  fileInfoEx
}

type fileInfoEx interface {
	os.FileInfo
	MD5Checksum() string
}

type bindataFileInfo struct {
	name        string
	size        int64
	mode        os.FileMode
	modTime     time.Time
	md5checksum string
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) MD5Checksum() string {
	return fi.md5checksum
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _bindataManifestsBootstrappodyaml = []byte(`apiVersion: v1
kind: Pod
metadata:
  name: bootstrap-machine-config-operator
  namespace: {{.TargetNamespace}}
spec:
  initContainers:
  - name: machine-config-controller
    image: {{.Images.MachineConfigController}}
    args:
    - "bootstrap"
    - "--manifest-dir=/etc/mcc/bootstrap/manifests"
    - "--dest-dir=/etc/mcc/bootstrap/server"
    - "--pull-secret=/etc/mcc/bootstrap/manifests/machineconfigcontroller-pull-secret"
    resources:
      limits:
        cpu: 20m
        memory: 50Mi
      requests:
        cpu: 20m
        memory: 50Mi
    securityContext:
      privileged: true
    volumeMounts:
    - name: bootstrap-manifests
      mountPath: /etc/mcc/bootstrap/manifests
    - name: server-basedir
      mountPath: /etc/mcc/bootstrap/server
  containers:
  - name: machine-config-server
    image: {{.Images.MachineConfigServer}}
    args:
      - "bootstrap"
    volumeMounts:
    - name: certs
      mountPath: /etc/ssl/mcs
    - name: etc-kubernetes
      mountPath: /etc/kubernetes/kubeconfig
    - name: server-basedir
      mountPath: /etc/mcs/bootstrap
    - name:  etcd-certs
      mountPath: /etc/ssl/etcd
    securityContext:
      privileged: true
  hostNetwork: true
  tolerations:
    - key: node-role.kubernetes.io/master
      operator: Exists
      effect: NoSchedule
  restartPolicy: Always
  volumes:
  - name: certs
    hostPath:
      path: /etc/ssl/mcs
  - name: etc-kubernetes
    hostPath:
      path: /etc/kubernetes/kubeconfig
  - name: server-basedir
    hostPath:
      path: /etc/mcs/bootstrap
  - name: etcd-certs
    hostPath:
      path: /etc/ssl/etcd
  - name: bootstrap-manifests
    hostPath:
      path: /etc/mcc/bootstrap/manifests
`)

func bindataManifestsBootstrappodyamlBytes() ([]byte, error) {
	return _bindataManifestsBootstrappodyaml, nil
}



func bindataManifestsBootstrappodyaml() (*asset, error) {
	bytes, err := bindataManifestsBootstrappodyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/bootstrap-pod.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsControllerconfigcrdyaml = []byte(`apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: <plural>.<group>
  name: controllerconfigs.machineconfiguration.openshift.io
spec:
  # group name to use for REST API: /apis/<group>/<version>
  group: machineconfiguration.openshift.io
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v1
      # Each version can be enabled/disabled by Served flag.
      served: true
      # One and only one version must be marked as the storage version.
      storage: true
  # either Namespaced or Cluster
  scope: Namespaced
  names:
    # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    plural: controllerconfigs
    # singular name to be used as an alias on the CLI and for display
    singular: controllerconfig
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: ControllerConfig
`)

func bindataManifestsControllerconfigcrdyamlBytes() ([]byte, error) {
	return _bindataManifestsControllerconfigcrdyaml, nil
}



func bindataManifestsControllerconfigcrdyaml() (*asset, error) {
	bytes, err := bindataManifestsControllerconfigcrdyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/controllerconfig.crd.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigcrdyaml = []byte(`apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: <plural>.<group>
  name: machineconfigs.machineconfiguration.openshift.io
spec:
  # group name to use for REST API: /apis/<group>/<version>
  group: machineconfiguration.openshift.io
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v1
      # Each version can be enabled/disabled by Served flag.
      served: true
      # One and only one version must be marked as the storage version.
      storage: true
  # either Namespaced or Cluster
  scope: Cluster
  names:
    # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    plural: machineconfigs
    # singular name to be used as an alias on the CLI and for display
    singular: machineconfig
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: MachineConfig
`)

func bindataManifestsMachineconfigcrdyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigcrdyaml, nil
}



func bindataManifestsMachineconfigcrdyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigcrdyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfig.crd.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigcontrollerClusterroleyaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: machine-config-controller
  namespace: {{.TargetNamespace}}
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "watch", "patch"]
- apiGroups: ["machineconfiguration.openshift.io"]
  resources: ["*"]
  verbs: ["*"]
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["*"]
`)

func bindataManifestsMachineconfigcontrollerClusterroleyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigcontrollerClusterroleyaml, nil
}



func bindataManifestsMachineconfigcontrollerClusterroleyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigcontrollerClusterroleyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigcontroller/clusterrole.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigcontrollerClusterrolebindingyaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: machine-config-controller
  namespace: {{.TargetNamespace}}
roleRef:
  kind: ClusterRole
  name: machine-config-controller
subjects:
- kind: ServiceAccount
  namespace: {{.TargetNamespace}}
  name: machine-config-controller
`)

func bindataManifestsMachineconfigcontrollerClusterrolebindingyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigcontrollerClusterrolebindingyaml, nil
}



func bindataManifestsMachineconfigcontrollerClusterrolebindingyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigcontrollerClusterrolebindingyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigcontroller/clusterrolebinding.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigcontrollerControllerconfigyaml = []byte(`apiVersion: machineconfiguration.openshift.io/v1
kind: ControllerConfig
metadata:
  name: machine-config-controller
  namespace: {{.TargetNamespace}}
spec:
{{toYAML .ControllerConfig | toString | indent 2}}
`)

func bindataManifestsMachineconfigcontrollerControllerconfigyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigcontrollerControllerconfigyaml, nil
}



func bindataManifestsMachineconfigcontrollerControllerconfigyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigcontrollerControllerconfigyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigcontroller/controllerconfig.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigcontrollerDeploymentyaml = []byte(`apiVersion: apps/v1
kind: Deployment
metadata:
  name: machine-config-controller
  namespace: {{.TargetNamespace}}
spec:
  selector:
    matchLabels:
      k8s-app: machine-config-controller
  template:
    metadata:
      labels:
        k8s-app: machine-config-controller
    spec:
      containers:
      - name: machine-config-controller
        image: {{.Images.MachineConfigController}}
        args:
        - "start"
        - "--resourcelock-namespace={{.TargetNamespace}}"
        resources:
          limits:
            cpu: 20m
            memory: 50Mi
          requests:
            cpu: 20m
            memory: 50Mi
      serviceAccountName: machine-config-controller
      nodeSelector:
        node-role.kubernetes.io/master: ""
      restartPolicy: Always
      tolerations:
      - key: "node-role.kubernetes.io/master"
        operator: "Exists"
        effect: "NoSchedule"`)

func bindataManifestsMachineconfigcontrollerDeploymentyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigcontrollerDeploymentyaml, nil
}



func bindataManifestsMachineconfigcontrollerDeploymentyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigcontrollerDeploymentyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigcontroller/deployment.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigcontrollerSayaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: {{.TargetNamespace}}
  name: machine-config-controller
`)

func bindataManifestsMachineconfigcontrollerSayamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigcontrollerSayaml, nil
}



func bindataManifestsMachineconfigcontrollerSayaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigcontrollerSayamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigcontroller/sa.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigdaemonOWNERS = []byte(`# See the OWNERS docs: https://git.k8s.io/community/contributors/guide/owners.md

approvers:
  - machine-config-daemon-approvers
`)

func bindataManifestsMachineconfigdaemonOWNERSBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigdaemonOWNERS, nil
}



func bindataManifestsMachineconfigdaemonOWNERS() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigdaemonOWNERSBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigdaemon/OWNERS",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigdaemonClusterroleyaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: machine-config-daemon
  namespace: {{.TargetNamespace}}
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "watch", "patch", "update"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["*"]
- apiGroups: ["extensions"]
  resources: ["daemonsets"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["pods/eviction"]
  verbs: ["create"]
- apiGroups: ["machineconfiguration.openshift.io"]
  resources: ["machineconfigs"]
  verbs: ["*"]
`)

func bindataManifestsMachineconfigdaemonClusterroleyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigdaemonClusterroleyaml, nil
}



func bindataManifestsMachineconfigdaemonClusterroleyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigdaemonClusterroleyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigdaemon/clusterrole.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigdaemonClusterrolebindingyaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: machine-config-daemon
  namespace: {{.TargetNamespace}}
roleRef:
  kind: ClusterRole
  name: machine-config-daemon
subjects:
- kind: ServiceAccount
  namespace: {{.TargetNamespace}}
  name: machine-config-daemon
`)

func bindataManifestsMachineconfigdaemonClusterrolebindingyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigdaemonClusterrolebindingyaml, nil
}



func bindataManifestsMachineconfigdaemonClusterrolebindingyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigdaemonClusterrolebindingyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigdaemon/clusterrolebinding.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigdaemonDaemonsetyaml = []byte(`apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: machine-config-daemon
  namespace: {{.TargetNamespace}}
spec:
  selector:
    matchLabels:
      k8s-app: machine-config-daemon
  template:
    metadata:
      name: machine-config-daemon
      labels:
        k8s-app: machine-config-daemon
    spec:
      containers:
      - name: machine-config-daemon
        image: {{.Images.MachineConfigDaemon}}
        args:
          - "start"
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /rootfs
            name: rootfs
          - mountPath: /var/run/dbus
            name: var-run-dbus
          - mountPath: /run/systemd
            name: run-systemd
          - mountPath: /etc/ssl/certs
            name: etc-ssl-certs
            readOnly: true
          - mountPath: /etc/machine-config-daemon
            name: etc-mcd
            readOnly: true
        env:
          - name: NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
      hostNetwork: true
      hostPID: true
      serviceAccountName: machine-config-daemon
      tolerations:
        - key: node-role.kubernetes.io/master
          operator: Exists
          effect: NoSchedule
        - key: node-role.kubernetes.io/etcd
          operator: Exists
          effect: NoSchedule
      volumes:
        - name: rootfs
          hostPath:
            path: /
        - name: var-run-dbus
          hostPath:
            path: /var/run/dbus
        - name: run-systemd
          hostPath:
            path: /run/systemd
        - name: etc-ssl-certs
          hostPath:
            path: /etc/ssl/certs
        - name: etc-mcd
          hostPath:
            path: /etc/machine-config-daemon
`)

func bindataManifestsMachineconfigdaemonDaemonsetyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigdaemonDaemonsetyaml, nil
}



func bindataManifestsMachineconfigdaemonDaemonsetyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigdaemonDaemonsetyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigdaemon/daemonset.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigdaemonSayaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: {{.TargetNamespace}}
  name: machine-config-daemon
`)

func bindataManifestsMachineconfigdaemonSayamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigdaemonSayaml, nil
}



func bindataManifestsMachineconfigdaemonSayaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigdaemonSayamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigdaemon/sa.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigpoolcrdyaml = []byte(`apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: <plural>.<group>
  name: machineconfigpools.machineconfiguration.openshift.io
spec:
  # group name to use for REST API: /apis/<group>/<version>
  group: machineconfiguration.openshift.io
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v1
      # Each version can be enabled/disabled by Served flag.
      served: true
      # One and only one version must be marked as the storage version.
      storage: true
  # either Namespaced or Cluster
  scope: Cluster
  subresources:
    status: {}
  names:
    # plural name to be used in the URL: /apis/<group>/<version>/<plural>
    plural: machineconfigpools
    # singular name to be used as an alias on the CLI and for display
    singular: machineconfigpool
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: MachineConfigPool
`)

func bindataManifestsMachineconfigpoolcrdyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigpoolcrdyaml, nil
}



func bindataManifestsMachineconfigpoolcrdyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigpoolcrdyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigpool.crd.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverClusterroleyaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: machine-config-server
  namespace: {{.TargetNamespace}}
rules:
- apiGroups: ["machineconfiguration.openshift.io"]
  resources: ["machineconfigs", "machineconfigpools"]
  verbs: ["*"]
`)

func bindataManifestsMachineconfigserverClusterroleyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverClusterroleyaml, nil
}



func bindataManifestsMachineconfigserverClusterroleyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverClusterroleyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/clusterrole.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverClusterrolebindingyaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: machine-config-server
  namespace: {{.TargetNamespace}}
roleRef:
  kind: ClusterRole
  name: machine-config-server
subjects:
- kind: ServiceAccount
  namespace: {{.TargetNamespace}}
  name: machine-config-server
`)

func bindataManifestsMachineconfigserverClusterrolebindingyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverClusterrolebindingyaml, nil
}



func bindataManifestsMachineconfigserverClusterrolebindingyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverClusterrolebindingyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/clusterrolebinding.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverCsrapproverrolebindingyaml = []byte(`# CSRApproverRoleBindingTemplate instructs the csrapprover controller to
# automatically approve CSRs made by serviceaccount node-bootstrapper in openshift-machine-config-operator
# for client credentials.
#
# This binding should be removed to disable CSR auto-approval.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system-bootstrap-approve-node-client-csr
subjects:
- kind: ServiceAccount
  name: node-bootstrapper
  namespace: openshift-machine-config-operator
roleRef:
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient
  apiGroup: rbac.authorization.k8s.io`)

func bindataManifestsMachineconfigserverCsrapproverrolebindingyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverCsrapproverrolebindingyaml, nil
}



func bindataManifestsMachineconfigserverCsrapproverrolebindingyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverCsrapproverrolebindingyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/csr-approver-role-binding.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverCsrbootstraprolebindingyaml = []byte(((`# system-bootstrap-node-bootstrapper lets serviceaccount ` + "`") + (`openshift-machine-config-operator/node-bootstrapper` + ("`" + ` tokens and nodes request CSRs.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system-bootstrap-node-bootstrapper
subjects:
- kind: ServiceAccount
  name: node-bootstrapper
  namespace: openshift-machine-config-operator
roleRef:
  kind: ClusterRole
  name: system:node-bootstrapper
  apiGroup: rbac.authorization.k8s.io`))))

func bindataManifestsMachineconfigserverCsrbootstraprolebindingyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverCsrbootstraprolebindingyaml, nil
}



func bindataManifestsMachineconfigserverCsrbootstraprolebindingyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverCsrbootstraprolebindingyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/csr-bootstrap-role-binding.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverCsrrenewalrolebindingyaml = []byte(((`# CSRRenewalRoleBindingTemplate instructs the csrapprover controller to
# automatically approve all CSRs made by nodes to renew their client
# certificates.
#
# This binding should be altered in the future to hold a list of node
# names instead of targeting ` + "`") + (`system:nodes` + ("`" + ` so we can revoke invidivual
# node's ability to renew its certs.
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system-bootstrap-node-renewal
subjects:
- kind: Group
  name: system:nodes
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient
  apiGroup: rbac.authorization.k8s.io`))))

func bindataManifestsMachineconfigserverCsrrenewalrolebindingyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverCsrrenewalrolebindingyaml, nil
}



func bindataManifestsMachineconfigserverCsrrenewalrolebindingyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverCsrrenewalrolebindingyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/csr-renewal-role-binding.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverDaemonsetyaml = []byte(`apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: machine-config-server
  namespace: {{.TargetNamespace}}
spec:
  selector:
    matchLabels:
      k8s-app: machine-config-server
  template:
    metadata:
      name: machine-config-server
      labels:
        k8s-app: machine-config-server
    spec:
      containers:
      - name: machine-config-server
        image: {{.Images.MachineConfigServer}}
        args:
          - "start"
          - "--apiserver-url=https://{{.ControllerConfig.ClusterName}}-api.{{.ControllerConfig.BaseDomain}}:6443"
        volumeMounts:
        - name: certs
          mountPath: /etc/ssl/mcs
        - name: node-bootstrap-token
          mountPath: /etc/mcs/bootstrap-token
      hostNetwork: true
      nodeSelector:
        node-role.kubernetes.io/master: ""
      serviceAccountName: machine-config-server
      tolerations:
        - key: node-role.kubernetes.io/master
          operator: Exists
          effect: NoSchedule
      volumes:
      - name: node-bootstrap-token
        secret:
          secretName: node-bootstrapper-token
      - name: certs
        secret:
          secretName: machine-config-server-tls
`)

func bindataManifestsMachineconfigserverDaemonsetyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverDaemonsetyaml, nil
}



func bindataManifestsMachineconfigserverDaemonsetyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverDaemonsetyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/daemonset.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverNodebootstrappersayaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: {{.TargetNamespace}}
  name: node-bootstrapper
`)

func bindataManifestsMachineconfigserverNodebootstrappersayamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverNodebootstrappersayaml, nil
}



func bindataManifestsMachineconfigserverNodebootstrappersayaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverNodebootstrappersayamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/node-bootstrapper-sa.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverNodebootstrappertokenyaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: node-bootstrapper
  name: node-bootstrapper-token
  namespace: {{.TargetNamespace}}
type: kubernetes.io/service-account-token
`)

func bindataManifestsMachineconfigserverNodebootstrappertokenyamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverNodebootstrappertokenyaml, nil
}



func bindataManifestsMachineconfigserverNodebootstrappertokenyaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverNodebootstrappertokenyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/node-bootstrapper-token.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMachineconfigserverSayaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: {{.TargetNamespace}}
  name: machine-config-server
`)

func bindataManifestsMachineconfigserverSayamlBytes() ([]byte, error) {
	return _bindataManifestsMachineconfigserverSayaml, nil
}



func bindataManifestsMachineconfigserverSayaml() (*asset, error) {
	bytes, err := bindataManifestsMachineconfigserverSayamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/machineconfigserver/sa.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsMastermachineconfigpoolyaml = []byte(`apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  name: master
spec:
  machineConfigSelector:
    matchLabels:
      "machineconfiguration.openshift.io/role": "master"
  machineSelector:
    matchLabels:
      node-role.kubernetes.io/master: ""`)

func bindataManifestsMastermachineconfigpoolyamlBytes() ([]byte, error) {
	return _bindataManifestsMastermachineconfigpoolyaml, nil
}



func bindataManifestsMastermachineconfigpoolyaml() (*asset, error) {
	bytes, err := bindataManifestsMastermachineconfigpoolyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/master.machineconfigpool.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}

var _bindataManifestsWorkermachineconfigpoolyaml = []byte(`apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  name: worker
spec:
  machineConfigSelector:
    matchLabels:
      "machineconfiguration.openshift.io/role": "worker"
  machineSelector:
    matchLabels:
      node-role.kubernetes.io/worker: ""`)

func bindataManifestsWorkermachineconfigpoolyamlBytes() ([]byte, error) {
	return _bindataManifestsWorkermachineconfigpoolyaml, nil
}



func bindataManifestsWorkermachineconfigpoolyaml() (*asset, error) {
	bytes, err := bindataManifestsWorkermachineconfigpoolyamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{
		name: "manifests/worker.machineconfigpool.yaml",
		size: 0,
		md5checksum: "",
		mode: os.FileMode(0),
		modTime: time.Unix(0, 0),
	}

	a := &asset{bytes: bytes, info: info}

	return a, nil
}


//
// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
//
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
}

//
// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
// nolint: deadcode
//
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

//
// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or could not be loaded.
//
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, &os.PathError{Op: "open", Path: name, Err: os.ErrNotExist}
}

//
// AssetNames returns the names of the assets.
// nolint: deadcode
//
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

//
// _bindata is a table, holding each asset generator, mapped to its name.
//
var _bindata = map[string]func() (*asset, error){
	"manifests/bootstrap-pod.yaml":                                  bindataManifestsBootstrappodyaml,
	"manifests/controllerconfig.crd.yaml":                           bindataManifestsControllerconfigcrdyaml,
	"manifests/machineconfig.crd.yaml":                              bindataManifestsMachineconfigcrdyaml,
	"manifests/machineconfigcontroller/clusterrole.yaml":            bindataManifestsMachineconfigcontrollerClusterroleyaml,
	"manifests/machineconfigcontroller/clusterrolebinding.yaml":     bindataManifestsMachineconfigcontrollerClusterrolebindingyaml,
	"manifests/machineconfigcontroller/controllerconfig.yaml":       bindataManifestsMachineconfigcontrollerControllerconfigyaml,
	"manifests/machineconfigcontroller/deployment.yaml":             bindataManifestsMachineconfigcontrollerDeploymentyaml,
	"manifests/machineconfigcontroller/sa.yaml":                     bindataManifestsMachineconfigcontrollerSayaml,
	"manifests/machineconfigdaemon/OWNERS":                          bindataManifestsMachineconfigdaemonOWNERS,
	"manifests/machineconfigdaemon/clusterrole.yaml":                bindataManifestsMachineconfigdaemonClusterroleyaml,
	"manifests/machineconfigdaemon/clusterrolebinding.yaml":         bindataManifestsMachineconfigdaemonClusterrolebindingyaml,
	"manifests/machineconfigdaemon/daemonset.yaml":                  bindataManifestsMachineconfigdaemonDaemonsetyaml,
	"manifests/machineconfigdaemon/sa.yaml":                         bindataManifestsMachineconfigdaemonSayaml,
	"manifests/machineconfigpool.crd.yaml":                          bindataManifestsMachineconfigpoolcrdyaml,
	"manifests/machineconfigserver/clusterrole.yaml":                bindataManifestsMachineconfigserverClusterroleyaml,
	"manifests/machineconfigserver/clusterrolebinding.yaml":         bindataManifestsMachineconfigserverClusterrolebindingyaml,
	"manifests/machineconfigserver/csr-approver-role-binding.yaml":  bindataManifestsMachineconfigserverCsrapproverrolebindingyaml,
	"manifests/machineconfigserver/csr-bootstrap-role-binding.yaml": bindataManifestsMachineconfigserverCsrbootstraprolebindingyaml,
	"manifests/machineconfigserver/csr-renewal-role-binding.yaml":   bindataManifestsMachineconfigserverCsrrenewalrolebindingyaml,
	"manifests/machineconfigserver/daemonset.yaml":                  bindataManifestsMachineconfigserverDaemonsetyaml,
	"manifests/machineconfigserver/node-bootstrapper-sa.yaml":       bindataManifestsMachineconfigserverNodebootstrappersayaml,
	"manifests/machineconfigserver/node-bootstrapper-token.yaml":    bindataManifestsMachineconfigserverNodebootstrappertokenyaml,
	"manifests/machineconfigserver/sa.yaml":                         bindataManifestsMachineconfigserverSayaml,
	"manifests/master.machineconfigpool.yaml":                       bindataManifestsMastermachineconfigpoolyaml,
	"manifests/worker.machineconfigpool.yaml":                       bindataManifestsWorkermachineconfigpoolyaml,
}

//
// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
//
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, &os.PathError{
					Op: "open",
					Path: name,
					Err: os.ErrNotExist,
				}
			}
		}
	}
	if node.Func != nil {
		return nil, &os.PathError{
			Op: "open",
			Path: name,
			Err: os.ErrNotExist,
		}
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}


type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{Func: nil, Children: map[string]*bintree{
	"manifests": {Func: nil, Children: map[string]*bintree{
		"bootstrap-pod.yaml": {Func: bindataManifestsBootstrappodyaml, Children: map[string]*bintree{}},
		"controllerconfig.crd.yaml": {Func: bindataManifestsControllerconfigcrdyaml, Children: map[string]*bintree{}},
		"machineconfig.crd.yaml": {Func: bindataManifestsMachineconfigcrdyaml, Children: map[string]*bintree{}},
		"machineconfigcontroller": {Func: nil, Children: map[string]*bintree{
			"clusterrole.yaml": {Func: bindataManifestsMachineconfigcontrollerClusterroleyaml, Children: map[string]*bintree{}},
			"clusterrolebinding.yaml": {Func: bindataManifestsMachineconfigcontrollerClusterrolebindingyaml, Children: map[string]*bintree{}},
			"controllerconfig.yaml": {Func: bindataManifestsMachineconfigcontrollerControllerconfigyaml, Children: map[string]*bintree{}},
			"deployment.yaml": {Func: bindataManifestsMachineconfigcontrollerDeploymentyaml, Children: map[string]*bintree{}},
			"sa.yaml": {Func: bindataManifestsMachineconfigcontrollerSayaml, Children: map[string]*bintree{}},
		}},
		"machineconfigdaemon": {Func: nil, Children: map[string]*bintree{
			"OWNERS": {Func: bindataManifestsMachineconfigdaemonOWNERS, Children: map[string]*bintree{}},
			"clusterrole.yaml": {Func: bindataManifestsMachineconfigdaemonClusterroleyaml, Children: map[string]*bintree{}},
			"clusterrolebinding.yaml": {Func: bindataManifestsMachineconfigdaemonClusterrolebindingyaml, Children: map[string]*bintree{}},
			"daemonset.yaml": {Func: bindataManifestsMachineconfigdaemonDaemonsetyaml, Children: map[string]*bintree{}},
			"sa.yaml": {Func: bindataManifestsMachineconfigdaemonSayaml, Children: map[string]*bintree{}},
		}},
		"machineconfigpool.crd.yaml": {Func: bindataManifestsMachineconfigpoolcrdyaml, Children: map[string]*bintree{}},
		"machineconfigserver": {Func: nil, Children: map[string]*bintree{
			"clusterrole.yaml": {Func: bindataManifestsMachineconfigserverClusterroleyaml, Children: map[string]*bintree{}},
			"clusterrolebinding.yaml": {Func: bindataManifestsMachineconfigserverClusterrolebindingyaml, Children: map[string]*bintree{}},
			"csr-approver-role-binding.yaml": {Func: bindataManifestsMachineconfigserverCsrapproverrolebindingyaml, Children: map[string]*bintree{}},
			"csr-bootstrap-role-binding.yaml": {Func: bindataManifestsMachineconfigserverCsrbootstraprolebindingyaml, Children: map[string]*bintree{}},
			"csr-renewal-role-binding.yaml": {Func: bindataManifestsMachineconfigserverCsrrenewalrolebindingyaml, Children: map[string]*bintree{}},
			"daemonset.yaml": {Func: bindataManifestsMachineconfigserverDaemonsetyaml, Children: map[string]*bintree{}},
			"node-bootstrapper-sa.yaml": {Func: bindataManifestsMachineconfigserverNodebootstrappersayaml, Children: map[string]*bintree{}},
			"node-bootstrapper-token.yaml": {Func: bindataManifestsMachineconfigserverNodebootstrappertokenyaml, Children: map[string]*bintree{}},
			"sa.yaml": {Func: bindataManifestsMachineconfigserverSayaml, Children: map[string]*bintree{}},
		}},
		"master.machineconfigpool.yaml": {Func: bindataManifestsMastermachineconfigpoolyaml, Children: map[string]*bintree{}},
		"worker.machineconfigpool.yaml": {Func: bindataManifestsWorkermachineconfigpoolyaml, Children: map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	return os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
